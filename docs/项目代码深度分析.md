# AutoRedTeam-Orchestrator é¡¹ç›®ä»£ç æ·±åº¦åˆ†æ

> å…¨é¢ä»£ç ç»“æ„åˆ†æä¸ä¼˜åŒ–å»ºè®®
>
> ç”Ÿæˆæ—¥æœŸ: 2026-01-13

---

## ä¸€ã€é¡¹ç›®æ¶æ„æ€»è§ˆ

### 1.1 ç›®å½•ç»“æ„

```
AutoRedTeam-Orchestrator/
â”œâ”€â”€ mcp_stdio_server.py          # MCPæœåŠ¡å™¨å…¥å£ (7KB)
â”œâ”€â”€ core/                        # æ ¸å¿ƒæ¨¡å— (26æ–‡ä»¶, 200KB+)
â”‚   â”œâ”€â”€ ai_engine.py             # AIå†³ç­–å¼•æ“ (22KB, 509è¡Œ)
â”‚   â”œâ”€â”€ tool_registry.py         # å·¥å…·æ³¨å†Œè¡¨ (17KB, 501è¡Œ)
â”‚   â”œâ”€â”€ session_manager.py       # ä¼šè¯ç®¡ç† (20KB, 588è¡Œ)
â”‚   â”œâ”€â”€ pipeline.py              # æ¼æ´æ£€æµ‹æµæ°´çº¿ (28KB, 726è¡Œ)
â”‚   â”œâ”€â”€ attack_chain.py          # æ”»å‡»é“¾å¼•æ“ (18KB, 511è¡Œ)
â”‚   â”œâ”€â”€ response_filter.py       # å“åº”è¿‡æ»¤/SPAæ£€æµ‹ (17KB, 481è¡Œ)
â”‚   â”œâ”€â”€ async_http_client.py     # å¼‚æ­¥HTTPå®¢æˆ·ç«¯ (7KB)
â”‚   â”œâ”€â”€ async_executor.py        # å¼‚æ­¥æ‰§è¡Œå™¨ (10KB)
â”‚   â”œâ”€â”€ result_aggregator.py     # ç»“æœèšåˆå™¨ (10KB)
â”‚   â”œâ”€â”€ concurrency_controller.py# å¹¶å‘æ§åˆ¶å™¨ (5KB)
â”‚   â”œâ”€â”€ mega_payload_library.py  # Payloadåº“ (10KB)
â”‚   â”œâ”€â”€ c2/                      # C2é€šä¿¡ (5æ–‡ä»¶, 63KB)
â”‚   â”‚   â”œâ”€â”€ beacon.py            # Beaconé€šä¿¡ (18KB) âš ï¸ å®‰å…¨æ¼æ´
â”‚   â”‚   â”œâ”€â”€ tunnels.py           # éš§é“æ¨¡å— (17KB)
â”‚   â”‚   â””â”€â”€ websocket_tunnel.py  # WebSocketéš§é“ (19KB)
â”‚   â”œâ”€â”€ cve/                     # CVEæƒ…æŠ¥ (14æ–‡ä»¶, 130KB)
â”‚   â”‚   â”œâ”€â”€ poc_engine.py        # YAML PoCå¼•æ“ (24KB)
â”‚   â”‚   â”œâ”€â”€ ai_poc_generator.py  # AI PoCç”Ÿæˆ (24KB)
â”‚   â”‚   â””â”€â”€ subscription_manager.py # CVEè®¢é˜… (30KB)
â”‚   â”œâ”€â”€ security/                # å®‰å…¨åŠ å›º (5æ–‡ä»¶)
â”‚   â”œâ”€â”€ performance/             # æ€§èƒ½ä¼˜åŒ– (8æ–‡ä»¶)
â”‚   â”œâ”€â”€ recon/                   # ä¾¦å¯Ÿå¼•æ“ (3æ–‡ä»¶)
â”‚   â”œâ”€â”€ lateral/                 # æ¨ªå‘ç§»åŠ¨ (4æ–‡ä»¶)
â”‚   â””â”€â”€ credential/              # å‡­è¯æå– (3æ–‡ä»¶)
â”œâ”€â”€ tools/                       # MCPå·¥å…· (18æ–‡ä»¶, 400KB+)
â”‚   â”œâ”€â”€ vuln_tools.py            # æ¼æ´æ£€æµ‹ (173KB, 4034è¡Œ) ğŸ”´ å¾…æ‹†åˆ†
â”‚   â”œâ”€â”€ web_scan_tools.py        # Webæ‰«æ (31KB, 766è¡Œ)
â”‚   â”œâ”€â”€ recon_tools.py           # ä¾¦å¯Ÿå·¥å…· (28KB)
â”‚   â”œâ”€â”€ ai_tools.py              # AIå·¥å…· (30KB, 716è¡Œ)
â”‚   â”œâ”€â”€ pentest_tools.py         # æ¸—é€æµ‹è¯• (30KB, 707è¡Œ)
â”‚   â”œâ”€â”€ detectors/               # æ£€æµ‹å™¨æ¨¡å— (23æ–‡ä»¶)
â”‚   â”‚   â”œâ”€â”€ base.py              # æ£€æµ‹å™¨åŸºç±» (14KB)
â”‚   â”‚   â”œâ”€â”€ factory.py           # æ£€æµ‹å™¨å·¥å‚ (7KB)
â”‚   â”‚   â”œâ”€â”€ injection/           # æ³¨å…¥æ£€æµ‹ (7æ–‡ä»¶, 70KB)
â”‚   â”‚   â”œâ”€â”€ request/             # è¯·æ±‚æ£€æµ‹ (4æ–‡ä»¶)
â”‚   â”‚   â”œâ”€â”€ file/                # æ–‡ä»¶æ£€æµ‹ (3æ–‡ä»¶)
â”‚   â”‚   â””â”€â”€ auth/                # è®¤è¯æ£€æµ‹ (3æ–‡ä»¶)
â”‚   â”œâ”€â”€ payloads/                # Payloadç®¡ç†
â”‚   â””â”€â”€ strategies/              # æ£€æµ‹ç­–ç•¥
â”œâ”€â”€ modules/                     # åŠŸèƒ½æ¨¡å— (41æ–‡ä»¶, 500KB+)
â”‚   â”œâ”€â”€ vuln_verifier.py         # æ¼æ´éªŒè¯ (46KB, 1169è¡Œ) ğŸŸ  ä¸´ç•Œ
â”‚   â”œâ”€â”€ redteam_tools.py         # RedTeamå·¥å…· (46KB, 1498è¡Œ) ğŸ”´ å¾…æ‹†åˆ†
â”‚   â”œâ”€â”€ mega_payloads.py         # Payloadåº“ (44KB, 775è¡Œ)
â”‚   â”œâ”€â”€ smart_payload_engine.py  # æ™ºèƒ½Payload (30KB, 800è¡Œ)
â”‚   â”œâ”€â”€ async_scanner.py         # å¼‚æ­¥æ‰«æ (19KB, 572è¡Œ)
â”‚   â”œâ”€â”€ nuclei_integration.py    # Nucleié›†æˆ (24KB, 649è¡Œ)
â”‚   â”œâ”€â”€ oob_detector.py          # OOBæ£€æµ‹ (12KB, 391è¡Œ)
â”‚   â”œâ”€â”€ web_scanner/             # Webæ‰«æå¼•æ“
â”‚   â”œâ”€â”€ api_security/            # APIå®‰å…¨
â”‚   â”œâ”€â”€ supply_chain/            # ä¾›åº”é“¾å®‰å…¨
â”‚   â””â”€â”€ cloud_security/          # äº‘å®‰å…¨
â””â”€â”€ utils/                       # å·¥å…·å‡½æ•° (13æ–‡ä»¶, 120KB)
    â”œâ”€â”€ report_generator.py      # æŠ¥å‘Šç”Ÿæˆ (21KB, 542è¡Œ)
    â”œâ”€â”€ input_validator.py       # è¾“å…¥éªŒè¯ (11KB)
    â”œâ”€â”€ task_queue.py            # ä»»åŠ¡é˜Ÿåˆ— (7KB)
    â””â”€â”€ decorators.py            # è£…é¥°å™¨åº“ (8KB)
```

### 1.2 ä»£ç ç»Ÿè®¡

| ç±»åˆ« | æ–‡ä»¶æ•° | ä»£ç è¡Œæ•° | å¹³å‡è¡Œæ•°/æ–‡ä»¶ |
|------|--------|----------|---------------|
| core/ | 26 | ~6,000 | 230 |
| tools/ | 18 | ~8,500 | 472 |
| modules/ | 41 | ~12,000 | 293 |
| utils/ | 13 | ~2,500 | 192 |
| **æ€»è®¡** | **98** | **~29,000** | **296** |

### 1.3 è¶…å¤§æ–‡ä»¶æ¸…å• (éœ€æ‹†åˆ†)

| æ–‡ä»¶ | è¡Œæ•° | å¤§å° | çŠ¶æ€ | ä¼˜å…ˆçº§ |
|------|------|------|------|--------|
| `tools/vuln_tools.py` | 4,034 | 173KB | ğŸ”´ ä¸¥é‡è¶…æ ‡ | P0 |
| `modules/redteam_tools.py` | 1,498 | 46KB | ğŸ”´ è¶…æ ‡ | P1 |
| `modules/vuln_verifier.py` | 1,169 | 46KB | ğŸŸ  ä¸´ç•Œ | P1 |
| `modules/mega_payloads.py` | 775 | 44KB | ğŸŸ¡ æ•°æ®æ–‡ä»¶å¯æ¥å— | - |
| `tools/web_scan_tools.py` | 766 | 31KB | ğŸŸ¡ æ¥è¿‘ä¸´ç•Œ | P2 |
| `tools/ai_tools.py` | 716 | 30KB | ğŸŸ¡ æ¥è¿‘ä¸´ç•Œ | P2 |

---

## äºŒã€æ ¸å¿ƒæ¨¡å—æ·±åº¦åˆ†æ

### 2.1 AIå†³ç­–å¼•æ“ (`core/ai_engine.py`)

**èŒè´£**: ç›®æ ‡åˆ†æã€æ”»å‡»è§„åˆ’ã€å·¥å…·æ¨è

**ç±»ä¸æ–¹æ³•**:

```python
class AIDecisionEngine:
    - analyze_target(target, recon_data)     # åˆ†æç›®æ ‡
    - generate_attack_plan(target_type, ports, technologies)  # ç”Ÿæˆæ”»å‡»è®¡åˆ’
    - suggest_tools(current_phase)           # æ¨èå·¥å…·
    - _ai_enhance_analysis(recon_data)       # AIå¢å¼ºåˆ†æ
    - _identify_target_type(target)          # è¯†åˆ«ç›®æ ‡ç±»å‹
    - _generate_attack_vectors(target_type, ...)  # ç”Ÿæˆæ”»å‡»å‘é‡
```

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | è¡Œå· | æè¿° | å½±å“ |
|------|------|------|------|
| é™æ€æ”»å‡»å‘é‡æ˜ å°„ | 260-363 | ç¡¬ç¼–ç ç«¯å£â†’å·¥å…·æ˜ å°„ | æ–°æ¼æ´æ— æ³•è‡ªåŠ¨é€‚é… |
| å·¥å…·æ¨èå›ºåŒ– | 498-506 | é˜¶æ®µå›ºå®šæ¨èå·¥å…· | æ— ä¸Šä¸‹æ–‡æ„ŸçŸ¥ |
| é£é™©è¯„ä¼°ç®€å• | 219-228 | ç›´æ¥è¿”å›"unknown" | æ— å®é™…è¯„ä¼°é€»è¾‘ |
| AIå¢å¼ºä¾èµ–å¤–éƒ¨ | 402-480 | éœ€OpenAI/Anthropic | ç¦»çº¿æ— æ³•ä½¿ç”¨ |
| æ— å†å²å­¦ä¹  | - | ä¸è®°å½•æˆåŠŸ/å¤±è´¥ | æ— æ³•è‡ªæˆ‘ä¼˜åŒ– |

**ä¼˜åŒ–å»ºè®®**:

```python
# 1. åŠ¨æ€æ”»å‡»å‘é‡æ³¨å†Œ
class AttackVectorRegistry:
    _vectors: Dict[str, List[AttackVector]] = {}
    
    @classmethod
    def register(cls, vuln_type: str, vector: AttackVector):
        if vuln_type not in cls._vectors:
            cls._vectors[vuln_type] = []
        cls._vectors[vuln_type].append(vector)
    
    @classmethod
    def get_vectors(cls, target_features: Dict) -> List[AttackVector]:
        """æ ¹æ®ç›®æ ‡ç‰¹å¾é€‰æ‹©å‘é‡"""
        matched = []
        for vuln_type, vectors in cls._vectors.items():
            for v in vectors:
                if v.matches(target_features):
                    matched.append(v)
        return sorted(matched, key=lambda x: x.priority)

# 2. ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ¨è
def suggest_tools_contextual(self, context: Dict) -> List[Dict]:
    previous_results = context.get("previous_results", [])
    suggestions = []
    
    for result in previous_results:
        if result.get("type") == "tech_detect":
            for tech in result.get("technologies", []):
                if "wordpress" in tech.lower():
                    suggestions.append({
                        "tool": "wpscan",
                        "reason": f"æ£€æµ‹åˆ°{tech}",
                        "priority": 1
                    })
    return suggestions

# 3. å†å²å­¦ä¹ ç³»ç»Ÿ
class LearningFeedback:
    def record(self, target: str, vector: str, success: bool):
        """è®°å½•æ”»å‡»ç»“æœç”¨äºå­¦ä¹ """
        pass
    
    def get_success_rate(self, vector: str) -> float:
        """è·å–å†å²æˆåŠŸç‡"""
        pass
```

---

### 2.2 æ¼æ´æ£€æµ‹æµæ°´çº¿ (`core/pipeline.py`)

**èŒè´£**: ç¼–æ’ æŒ‡çº¹â†’å¼±å£ä»¤â†’æ¼æ´æ‰«æâ†’æ”»å‡»é“¾ æµç¨‹

**ç±»ä¸æ–¹æ³•**:

```python
class PipelineContext:
    - target: str
    - fingerprints: List[Dict]
    - weak_credentials: List[Dict]
    - vulnerabilities: List[Dict]
    - attack_chains: List[Dict]

class VulnerabilityPipeline:
    - run_full_pipeline()          # å®Œæ•´æµæ°´çº¿
    - _run_fingerprint_phase()     # æŒ‡çº¹è¯†åˆ«
    - _run_weak_password_phase()   # å¼±å£ä»¤æ£€æµ‹
    - _run_vuln_scan_phase()       # æ¼æ´æ‰«æ
    - _generate_attack_chains()    # æ”»å‡»é“¾ç”Ÿæˆ
```

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | è¡Œå· | æè¿° | å½±å“ |
|------|------|------|------|
| åŒæ­¥é˜»å¡ | 258-295 | å„é˜¶æ®µé¡ºåºæ‰§è¡Œ | æ•ˆç‡ä½ |
| æ— å¹¶è¡Œæ‰§è¡Œ | - | ç‹¬ç«‹é˜¶æ®µä¹Ÿé¡ºåºåŒ– | æ—¶é—´æµªè´¹ |
| å¼‚å¸¸å¤„ç†ç²—ç³™ | å¤šå¤„ | `except Exception` | éšè—é—®é¢˜ |
| æ— æ–­ç‚¹ç»­ä¼  | - | ä¸­æ–­éœ€å®Œå…¨é‡æ¥ | ç”¨æˆ·ä½“éªŒå·® |
| ç»“æœæœªæŒä¹…åŒ– | - | å†…å­˜ä¸­ä¸¢å¤± | æ•°æ®é£é™© |

**ä¼˜åŒ–å»ºè®®**:

```python
# 1. å¼‚æ­¥æµæ°´çº¿
async def run_full_pipeline_async(self) -> Dict:
    # å¹¶è¡Œæ‰§è¡Œç‹¬ç«‹é˜¶æ®µ
    fingerprint_task = asyncio.create_task(self._run_fingerprint_async())
    dns_task = asyncio.create_task(self._run_dns_enum_async())
    results = await asyncio.gather(fingerprint_task, dns_task)
    
    # ä¾èµ–é˜¶æ®µé¡ºåºæ‰§è¡Œ
    await self._run_vuln_scan_async()
    return self.context

# 2. æ–­ç‚¹ç»­ä¼ 
class CheckpointManager:
    async def save(self, pipeline_id: str, phase: str, context: Dict):
        await aiofiles.open(f"checkpoints/{pipeline_id}.json", "w")
    
    async def resume(self, pipeline_id: str) -> Tuple[str, PipelineContext]:
        # è¿”å› (phase, context)
        pass

# 3. ç»“æœæŒä¹…åŒ–
class ResultPersistence:
    async def save_incremental(self, target: str, findings: List[Dict]):
        """å¢é‡ä¿å­˜å‘ç°ç»“æœ"""
        pass
```

---

### 2.3 æ”»å‡»é“¾å¼•æ“ (`core/attack_chain.py`)

**èŒè´£**: åŸºäºMITRE ATT&CKæ¡†æ¶ç”Ÿæˆå’Œæ‰§è¡Œæ”»å‡»é“¾

**ç±»ä¸æ–¹æ³•**:

```python
class AttackPhase(Enum):
    RECONNAISSANCE, INITIAL_ACCESS, EXECUTION, 
    PERSISTENCE, PRIVILEGE_ESC, DEFENSE_EVASION,
    CREDENTIAL_ACCESS, DISCOVERY, LATERAL_MOVEMENT,
    COLLECTION, EXFILTRATION, IMPACT

class AttackNode:
    id, phase, technique, tool, params, dependencies, status, result

class AttackChain:
    id, name, target, nodes: List[AttackNode], status, findings

class AttackChainEngine:
    TECHNIQUE_TOOLS = {...}  # 50+æ˜ å°„
    - create_chain(target, target_type, objectives)
    - execute_chain(chain_id, session_id)
    - _generate_nodes(target, target_type, objectives)
    - _check_dependencies(chain, node)
    - _detect_cycle(chain)
    - _extract_findings(node, result)
    - _adjust_chain(chain, completed_node, result)
```

**æŠ€æœ¯åˆ°å·¥å…·æ˜ å°„**:

```python
TECHNIQUE_TOOLS = {
    "active_scanning": ["nmap_scan", "port_scan"],
    "passive_recon": ["shodan_lookup", "censys_lookup"],
    "vulnerability_scanning": ["sqli_detect", "xss_detect", ...],
    "exploitation": ["exploit_db", "metasploit"],
    "credential_access": ["weak_password_detect", "hash_crack"],
    "lateral_movement": ["smb_exec", "ssh_exec", "wmi_exec"],
    # ... 50+æ˜ å°„
}
```

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | è¡Œå· | æè¿° | å½±å“ |
|------|------|------|------|
| é¡ºåºæ‰§è¡ŒèŠ‚ç‚¹ | 255-316 | æ— å¹¶è¡Œä¼˜åŒ– | æ•ˆç‡ä½ |
| å¾ªç¯æ£€æµ‹ä¸å®Œæ•´ | 331-356 | æŸäº›å¤æ‚æƒ…å†µæ¼æ£€ | å¯èƒ½æ­»å¾ªç¯ |
| ç»“æœæå–å›ºå®š | 358-392 | ç¡¬ç¼–ç è§„åˆ™ | æ–°å·¥å…·éœ€æ”¹ä»£ç  |
| æ— æ‰§è¡Œæ—¥å¿— | - | ç¼ºå°‘è¯¦ç»†æ—¥å¿— | éš¾ä»¥è°ƒè¯• |
| è°ƒæ•´ç­–ç•¥ç®€å• | 394-423 | å›ºå®šè§„åˆ™ | ä¸å¤Ÿæ™ºèƒ½ |

**ä¼˜åŒ–å»ºè®®**:

```python
# 1. å¹¶è¡Œæ‰§è¡Œæ— ä¾èµ–èŠ‚ç‚¹
async def execute_chain_parallel(self, chain_id: str):
    chain = self._chains[chain_id]
    executed = set()
    
    while not self._is_complete(chain):
        # æ‰¾å‡ºå¯æ‰§è¡Œçš„èŠ‚ç‚¹(ä¾èµ–å·²æ»¡è¶³)
        ready_nodes = [
            n for n in chain.nodes 
            if n.id not in executed 
            and self._deps_satisfied(n, executed)
        ]
        
        # å¹¶è¡Œæ‰§è¡Œ
        tasks = [self._execute_node_async(n) for n in ready_nodes]
        await asyncio.gather(*tasks)
        executed.update(n.id for n in ready_nodes)

# 2. å¯æ’æ‹”çš„ç»“æœæå–å™¨
class ResultExtractorRegistry:
    _extractors: Dict[str, Callable] = {}
    
    @classmethod
    def register(cls, tool_name: str):
        def decorator(func):
            cls._extractors[tool_name] = func
            return func
        return decorator
    
    @classmethod
    def extract(cls, tool_name: str, result: Dict) -> List[Finding]:
        extractor = cls._extractors.get(tool_name, cls._default)
        return extractor(result)

@ResultExtractorRegistry.register("nmap_scan")
def extract_nmap_findings(result: Dict) -> List[Finding]:
    """ä»nmapç»“æœæå–å‘ç°"""
    pass
```

---

### 2.4 å“åº”è¿‡æ»¤å™¨ (`core/response_filter.py`)

**èŒè´£**: SPAæ£€æµ‹ã€è¯¯æŠ¥è¿‡æ»¤ã€æ•æ„Ÿæ–‡ä»¶éªŒè¯

**ç±»ä¸æ–¹æ³•**:

```python
class ResponseFilter:
    SPA_MARKERS = [...]  # React/Vue/Angular/Svelte/Next.jsç­‰æ ‡è®°
    LOGIN_MARKERS = [...]
    ERROR_MARKERS = [...]
    
    - calibrate(base_url)              # æ ¡å‡†åŸºçº¿
    - detect_spa(html)                 # SPAæ£€æµ‹
    - is_login_page(html)              # ç™»å½•é¡µæ£€æµ‹
    - is_error_page(html)              # é”™è¯¯é¡µæ£€æµ‹
    - is_spa_fallback(url, html, status)  # SPA fallbackåˆ¤æ–­
    - is_duplicate(url, html)          # é‡å¤å“åº”æ£€æµ‹
    - validate_sensitive_file(...)     # æ•æ„Ÿæ–‡ä»¶éªŒè¯
    - validate_auth_bypass(...)        # è®¤è¯ç»•è¿‡éªŒè¯
```

**SPAæ¡†æ¶æ”¯æŒ**:

```python
SPA_MARKERS = [
    # React
    '<div id="root">', 'data-reactroot', '__REACT_DEVTOOLS',
    # Vue
    '<div id="app">', '__VUE__', 'data-v-',
    # Angular
    'ng-app', 'ng-controller', '_ngcontent',
    # Svelte
    '$$scope', 'svelte-',
    # Next.js
    '__NEXT_DATA__', '_next/static',
    # Nuxt
    '__NUXT__', '_nuxt/static',
    # Remix
    '__remixContext',
]
```

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | è¡Œå· | æè¿° | å½±å“ |
|------|------|------|------|
| SPAæ£€æµ‹å¯èƒ½æ¼æ£€ | 23-78 | æ–°æ¡†æ¶æœªè¦†ç›– | è¯¯æŠ¥ |
| ç›¸ä¼¼åº¦ç®—æ³•ç®€å• | 387-397 | Jaccardç®€åŒ–ç‰ˆ | ç²¾åº¦ä¸è¶³ |
| æ— å­¦ä¹ æœºåˆ¶ | - | é™æ€è§„åˆ™ | æ— æ³•é€‚åº”æ–°æ¨¡å¼ |
| æ–‡ä»¶ç­¾åä¸å®Œæ•´ | 437-463 | éƒ¨åˆ†ç±»å‹æœªè¦†ç›– | è¯¯åˆ¤ |

**ä¼˜åŒ–å»ºè®®**:

```python
# 1. å¯æ‰©å±•çš„SPAæ£€æµ‹
class SPAMarkerRegistry:
    _markers: Dict[str, List[str]] = {}
    
    @classmethod
    def register(cls, framework: str, markers: List[str]):
        cls._markers[framework] = markers
    
    @classmethod
    def detect(cls, html: str) -> Dict[str, bool]:
        detected = {}
        for framework, markers in cls._markers.items():
            detected[framework] = any(m in html for m in markers)
        return detected

# è‡ªåŠ¨ä»CDN/npmæ›´æ–°æ¡†æ¶ç‰¹å¾
async def auto_update_markers():
    """ä»npm registryè·å–æœ€æ–°æ¡†æ¶æ ‡è¯†"""
    pass

# 2. é«˜æ€§èƒ½ç›¸ä¼¼åº¦è®¡ç®—
class SimHasher:
    """ä½¿ç”¨SimHashè¿›è¡Œé«˜æ•ˆç›¸ä¼¼åº¦è®¡ç®—"""
    def compute_hash(self, text: str) -> int:
        pass
    
    def hamming_distance(self, hash1: int, hash2: int) -> int:
        pass
    
    def similarity(self, text1: str, text2: str) -> float:
        h1, h2 = self.compute_hash(text1), self.compute_hash(text2)
        distance = self.hamming_distance(h1, h2)
        return 1 - (distance / 64)  # å‡è®¾64ä½hash
```

---

### 2.5 ä¼šè¯ç®¡ç†å™¨ (`core/session_manager.py`)

**èŒè´£**: ç®¡ç†æ¸—é€æµ‹è¯•ä¼šè¯ã€ç»“æœå­˜å‚¨

**ç±»ä¸æ–¹æ³•**:

```python
class SessionStatus(Enum):
    ACTIVE, PAUSED, COMPLETED, FAILED

class Target:
    value, type, metadata

class ExecutionResult:
    tool_name, params, result, timestamp, duration, success, error

class Session:
    id, name, created_at, status, targets, results, findings, notes

class SessionManager:
    - create_session(name)
    - get_session(session_id)
    - update_session_status(session_id, status)
    - save_session(session_id)  # å¸¦å®‰å…¨éªŒè¯
    - load_session(session_id)  # å¸¦å®‰å…¨éªŒè¯

class HTTPSessionManager:
    # HTTPä¼šè¯ç®¡ç†ï¼Œè®¤è¯çŠ¶æ€ä¿æŒ
    - create_auth_context(url, username, password)
    - refresh_auth(context)
```

**å®‰å…¨æªæ–½**:

```python
# Session IDéªŒè¯ (é˜²è·¯å¾„éå†)
SESSION_ID_PATTERN = re.compile(r'^[a-zA-Z0-9_-]{8,64}$')

def _validate_session_id(self, session_id: str) -> bool:
    return bool(SESSION_ID_PATTERN.match(session_id))

def _get_safe_filepath(self, session_id: str) -> Path:
    if not self._validate_session_id(session_id):
        raise ValueError("Invalid session ID")
    filepath = self._storage_path / f"{session_id}.json"
    # ç¡®ä¿è·¯å¾„åœ¨storage_pathå†…
    filepath.resolve().relative_to(self._storage_path.resolve())
    return filepath
```

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | è¡Œå· | æè¿° | å½±å“ |
|------|------|------|------|
| ä¼šè¯æ•°æ®å†…å­˜å­˜å‚¨ | 147-161 | é‡å¯ä¸¢å¤± | æ•°æ®ä¸¢å¤± |
| æ— å¹¶å‘æ§åˆ¶ | - | å¤šçº¿ç¨‹å¯èƒ½å†²çª | æ•°æ®ç«äº‰ |
| ç»“æœæŸ¥è¯¢æ— åˆ†é¡µ | 195-200 | å¤§é‡æ•°æ®å†…å­˜æº¢å‡º | æ€§èƒ½é—®é¢˜ |

---

## ä¸‰ã€å·¥å…·æ¨¡å—æ·±åº¦åˆ†æ

### 3.1 æ¼æ´æ£€æµ‹å·¥å…· (`tools/vuln_tools.py`) ğŸ”´ é‡ç‚¹

**ç°çŠ¶**: 4034è¡Œ, 173KB - **ä¸¥é‡éœ€è¦æ‹†åˆ†**

**åŒ…å«çš„æ£€æµ‹å™¨**:

| æ£€æµ‹å™¨ | è¡Œæ•° | åŠŸèƒ½ | æ£€æµ‹æ–¹æ³• |
|--------|------|------|----------|
| `sqli_detect` | 215 | SQLæ³¨å…¥ | æŠ¥é”™/æ—¶é—´ç›²æ³¨/å¸ƒå°”ç›²æ³¨ |
| `xss_detect` | 41 | XSS | åå°„æ£€æµ‹ |
| `csrf_detect` | 60 | CSRF | Tokenæ£€æµ‹ |
| `ssrf_detect` | 52 | SSRF | å†…éƒ¨åœ°å€æ¢æµ‹ |
| `xxe_detect` | 70 | XXE | XMLå®ä½“æ›¿æ¢ |
| `rce_detect` | 95 | RCE | æ—¶é—´å»¶è¿Ÿ/å›æ˜¾ |
| `file_upload_detect` | 110 | æ–‡ä»¶ä¸Šä¼  | æ‰©å±•å/MIMEç»•è¿‡ |
| `lfi_detect` | 85 | æœ¬åœ°æ–‡ä»¶åŒ…å« | è·¯å¾„éå† |
| `ssti_detect` | 78 | æ¨¡æ¿æ³¨å…¥ | è¡¨è¾¾å¼æ‰§è¡Œ |
| `idor_detect` | 92 | IDOR | IDéå† |
| `auth_bypass_detect` | 117 | è®¤è¯ç»•è¿‡ | è·¯å¾„/å‚æ•°å˜ä½“ |
| `nosql_detect` | 199 | NoSQLæ³¨å…¥ | MongoDB/Redis/ES |
| `jwt_detect` | 146 | JWTæ¼æ´ | ç­¾å/ç®—æ³•æ»¥ç”¨ |
| `cors_detect` | 89 | CORS | é…ç½®æ£€æµ‹ |
| `security_headers_check` | 98 | å®‰å…¨å¤´ | ç¼ºå¤±æ£€æµ‹ |
| `weak_password_detect` | 280 | å¼±å£ä»¤ | å­—å…¸çˆ†ç ´ |
| `waf_detect` | 125 | WAFæ£€æµ‹ | ç‰¹å¾è¯†åˆ« |
| `logic_flaw_detect` | 78 | é€»è¾‘æ¼æ´ | æµç¨‹åˆ†æ |
| `deserialize_detect` | 107 | ååºåˆ—åŒ– | Gadgetæ£€æµ‹ |

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | ä¸¥é‡æ€§ | å½±å“ |
|------|--------|------|
| å•æ–‡ä»¶è¿‡å¤§ | ğŸ”´ é«˜ | åŠ è½½æ…¢ã€éš¾ç»´æŠ¤ |
| æ£€æµ‹é€»è¾‘é‡å¤ | ğŸŸ  ä¸­ | ä»£ç å†—ä½™30%+ |
| Payloadç¡¬ç¼–ç  | ğŸŸ  ä¸­ | æ›´æ–°å›°éš¾ |
| æ— å¹¶å‘æ§åˆ¶ | ğŸŸ  ä¸­ | è§¦å‘é™æµ |
| æ— ç»Ÿä¸€åŸºç±» | ğŸŸ¡ ä½ | æ¥å£ä¸ä¸€è‡´ |

**æ‹†åˆ†å»ºè®®**:

```
tools/detectors/
â”œâ”€â”€ injection/
â”‚   â”œâ”€â”€ sqli/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ error_based.py
â”‚   â”‚   â”œâ”€â”€ time_based.py
â”‚   â”‚   â”œâ”€â”€ boolean_based.py
â”‚   â”‚   â”œâ”€â”€ union_based.py
â”‚   â”‚   â””â”€â”€ oob.py
â”‚   â”œâ”€â”€ xss/
â”‚   â”‚   â”œâ”€â”€ reflected.py
â”‚   â”‚   â”œâ”€â”€ stored.py
â”‚   â”‚   â””â”€â”€ dom.py
â”‚   â”œâ”€â”€ nosql/
â”‚   â”‚   â”œâ”€â”€ mongodb.py
â”‚   â”‚   â”œâ”€â”€ redis.py
â”‚   â”‚   â””â”€â”€ elasticsearch.py
â”‚   â”œâ”€â”€ ssti.py
â”‚   â””â”€â”€ xxe.py
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ bypass.py
â”‚   â”œâ”€â”€ jwt.py
â”‚   â””â”€â”€ weak_password.py
â”œâ”€â”€ access/
â”‚   â”œâ”€â”€ idor.py
â”‚   â””â”€â”€ cors.py
â”œâ”€â”€ file/
â”‚   â”œâ”€â”€ upload.py
â”‚   â””â”€â”€ lfi.py
â””â”€â”€ misc/
    â”œâ”€â”€ csrf.py
    â”œâ”€â”€ ssrf.py
    â”œâ”€â”€ rce.py
    â”œâ”€â”€ deserialize.py
    â””â”€â”€ security_headers.py
```

---

### 3.2 æ£€æµ‹å™¨åŸºç±» (`tools/detectors/base.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class Vulnerability:
    vuln_type, severity, url, parameter, payload
    evidence, verified, confidence, remediation

class BaseDetector(ABC):
    name: str
    description: str
    severity: str
    
    @abstractmethod
    def get_payloads(self) -> List[str]
    
    @abstractmethod
    def validate_response(self, response, payload, baseline) -> bool
    
    def detect(self, url, param) -> Dict
    def _get_baseline(self, url) -> Dict
    def _send_request(self, url, method, data) -> Dict
```

**é—®é¢˜**:

- åŒæ­¥æ¥å£ï¼Œæ— å¼‚æ­¥ç‰ˆæœ¬
- Payloadè·å–åŒæ­¥ï¼Œå¤§é›†åˆåŠ è½½æ…¢
- æ— æ£€æµ‹ç­–ç•¥é€‰æ‹©æœºåˆ¶

---

### 3.3 SQLæ³¨å…¥æ£€æµ‹å™¨ (`tools/detectors/injection/sqli.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class SQLiDetector(BaseDetector):
    DEFAULT_PARAMS = ["id", "page", "cat", "search", ...]
    ERROR_PATTERNS = {...}  # MySQL/PostgreSQL/MSSQL/Oracle/SQLite
    TIME_PAYLOADS = {...}
    BOOLEAN_PAYLOADS = {...}
    
    - detect(url, param, deep_scan=True)
    - detect_time_based(url, param)
    - detect_boolean_based(url, param, baseline)
    - get_payloads() -> List[str]
    - validate_response(response, payload, baseline) -> bool
```

**æ£€æµ‹æ–¹æ³•è¦†ç›–**:

| æ–¹æ³• | æ”¯æŒ | ç¼ºå¤± |
|------|------|------|
| æŠ¥é”™æ³¨å…¥ | âœ… | - |
| æ—¶é—´ç›²æ³¨ | âœ… | - |
| å¸ƒå°”ç›²æ³¨ | âœ… | - |
| è”åˆæŸ¥è¯¢ | âŒ | éœ€æ·»åŠ  |
| å †å æŸ¥è¯¢ | âŒ | éœ€æ·»åŠ  |
| OOB (å¸¦å¤–) | âŒ | éœ€æ·»åŠ  |
| äºŒæ¬¡æ³¨å…¥ | âŒ | éœ€æ·»åŠ  |

**ä¼˜åŒ–å»ºè®®**:

```python
# æ·»åŠ è”åˆæŸ¥è¯¢æ£€æµ‹
def detect_union_based(self, url: str, param: str) -> Dict:
    """è”åˆæŸ¥è¯¢æ³¨å…¥æ£€æµ‹"""
    # 1. ç¡®å®šåˆ—æ•°
    for col_count in range(1, 20):
        payload = f"' UNION SELECT {','.join(['NULL']*col_count)}-- "
        response = self._send_request(url, param, payload)
        if self._validate_union_response(response):
            break
    
    # 2. ç¡®å®šå›æ˜¾ä½ç½®
    # 3. æå–æ•°æ®
    pass

# æ·»åŠ äºŒæ¬¡æ³¨å…¥æ£€æµ‹
def detect_second_order(self, url: str, store_param: str, 
                        trigger_url: str) -> Dict:
    """äºŒæ¬¡æ³¨å…¥æ£€æµ‹"""
    pass
```

---

### 3.4 XSSæ£€æµ‹å™¨ (`tools/detectors/injection/xss.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class XSSDetector(BaseDetector):
    DEFAULT_PARAMS = ["search", "q", "query", "keyword", ...]
    PAYLOADS = [...]  # åŸºç¡€/äº‹ä»¶/SVG/å¤šè¯­è¨€Payload
    
    - detect(url, param, deep_scan=True)
    - detect_reflected(url, param)
    - detect_dom_based(url, param)
    - _check_reflection(response_text, payload)
    - _analyze_context(response_text, payload)
```

**æ£€æµ‹æ–¹æ³•è¦†ç›–**:

| æ–¹æ³• | æ”¯æŒ | ç¼ºå¤± |
|------|------|------|
| åå°„å‹ | âœ… | - |
| DOMå‹(åŸºç¡€) | âœ… | å¤æ‚DOMåˆ†æ |
| å­˜å‚¨å‹ | âŒ | éœ€æ·»åŠ  |
| ç›²XSS | âŒ | éœ€æ·»åŠ  |
| mXSS | âŒ | éœ€æ·»åŠ  |

**ä¸Šä¸‹æ–‡åˆ†æç°çŠ¶**:

```python
def _analyze_context(self, response_text: str, payload: str) -> str:
    """åˆ†æPayloadåå°„çš„ä¸Šä¸‹æ–‡"""
    pos = response_text.find(payload)
    before = response_text[max(0, pos-50):pos]
    
    if '<script' in before.lower():
        return "script"
    elif re.search(r'<\w+[^>]*\w+\s*=\s*["\'][^"\']*$', before):
        return "attribute"
    elif re.search(r'<style[^>]*>.*$', before, re.S):
        return "style"
    else:
        return "html"
```

**ä¼˜åŒ–å»ºè®®**:

```python
# æ›´ç²¾ç»†çš„ä¸Šä¸‹æ–‡åˆ†æ
CONTEXT_PAYLOADS = {
    "html_body": ['<script>alert(1)</script>', '<img src=x onerror=alert(1)>'],
    "html_attribute_value": ['" onmouseover="alert(1)', "' onclick='alert(1)"],
    "html_attribute_unquoted": [' onmouseover=alert(1) '],
    "javascript_string": ["'-alert(1)-'", "\\';alert(1)//"],
    "javascript_block": [";alert(1)//", "};alert(1)//"],
    "css_value": ["expression(alert(1))", "url(javascript:alert(1))"],
    "url_param": ["javascript:alert(1)", "data:text/html,<script>alert(1)</script>"],
}

def detect_with_context(self, url: str, param: str) -> Dict:
    """ä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„XSSæ£€æµ‹"""
    # 1. å‘é€æ¢é’ˆç¡®å®šä¸Šä¸‹æ–‡
    probe = f"XSS_PROBE_{random.randint(1000,9999)}"
    response = self._send_request(url, param, probe)
    context = self._analyze_context_detailed(response.text, probe)
    
    # 2. é€‰æ‹©é€‚åˆä¸Šä¸‹æ–‡çš„Payload
    payloads = CONTEXT_PAYLOADS.get(context, CONTEXT_PAYLOADS["html_body"])
    
    # 3. æµ‹è¯•
    for payload in payloads:
        if self._test_xss(url, param, payload):
            return {"vulnerable": True, "context": context, "payload": payload}
```

---

### 3.5 Nucleié›†æˆ (`modules/nuclei_integration.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class NucleiScanner:
    TEMPLATE_CATEGORIES = {
        "cves": "CVEæ¼æ´",
        "vulnerabilities": "é€šç”¨æ¼æ´",
        "exposures": "ä¿¡æ¯æš´éœ²",
        "misconfiguration": "é”™è¯¯é…ç½®",
        "default-logins": "é»˜è®¤å‡­æ®",
        "file": "æ•æ„Ÿæ–‡ä»¶",
        "takeovers": "å­åŸŸæ¥ç®¡",
        "technologies": "æŠ€æœ¯æ£€æµ‹",
    }
    
    PRESETS = {
        "quick": {"severity": "critical,high", "timeout": 300},
        "full": {"all_templates": True, "timeout": 3600},
        "cve_only": {"tags": "cve", "timeout": 600},
        "web": {"tags": "web", "timeout": 600},
    }
    
    - scan(target, preset, severity, tags, ...)
    - scan_multiple(targets, preset)
    - scan_by_severity(target, severity)
    - smart_scan(target, detected_tech)  # æ™ºèƒ½æ‰«æ
    - verify_vulnerability(vuln, retry)  # éªŒè¯æ¼æ´
    - batch_verify(vulns, sample_size)   # æ‰¹é‡éªŒè¯
    - get_remediation(vuln)              # ä¿®å¤å»ºè®®
```

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | æè¿° | å½±å“ |
|------|------|------|
| ä¾èµ–å¤–éƒ¨å·¥å…· | éœ€è¦nucleiå¯æ‰§è¡Œæ–‡ä»¶ | ç¯å¢ƒä¾èµ– |
| æ¨¡æ¿æ›´æ–°æ‰‹åŠ¨ | éœ€è°ƒç”¨update_templates | æ¨¡æ¿å¯èƒ½è¿‡æ—¶ |
| ç»“æœè§£æä¸å®Œæ•´ | éƒ¨åˆ†å­—æ®µæœªè§£æ | ä¿¡æ¯ä¸¢å¤± |

---

## å››ã€æ¨¡å—æ·±åº¦åˆ†æ

### 4.1 æ¼æ´éªŒè¯å™¨ (`modules/vuln_verifier.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class VulnerabilityVerifier:
    - verify(vuln_type, url, param, payload)
    - _verify_xss(url, param, payload)
    - _verify_sqli(url, param, payload)
    - _verify_lfi(url, param, payload)
    - _verify_rce(url, param, payload)
    - _verify_ssrf(url, param, payload)
    - _analyze_xss_context(response, payload)

class StatisticalVerifier:
    - verify_with_stats(vuln_type, url, param, payload, rounds)
    - _calculate_confidence(results)

class OOBIntegratedVerifier:
    - verify_blind(vuln_type, url, param)
    - _create_oob_payload(vuln_type, identifier)
    - _poll_oob_server(identifier, timeout)
```

**éªŒè¯æ–¹æ³•è¦†ç›–**:

| æ¼æ´ç±»å‹ | å†…å¸¦éªŒè¯ | ç»Ÿè®¡éªŒè¯ | OOBéªŒè¯ |
|----------|----------|----------|---------|
| SQLi | âœ… | âœ… | âœ… |
| XSS | âœ… | âœ… | âŒ (å¯åŠ ç›²XSS) |
| LFI | âœ… | âŒ | âŒ |
| RCE | âœ… | âœ… | âœ… |
| SSRF | âœ… | âŒ | âœ… |
| XXE | âŒ | âŒ | âœ… |

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | æè¿° | å½±å“ |
|------|------|------|
| éªŒè¯è½®æ•°å›ºå®š | 3-10è½®å›ºå®š | æ•ˆç‡/å‡†ç¡®æ€§å¹³è¡¡å·® |
| ç½®ä¿¡åº¦è®¡ç®—ç®€å• | ç®€å•æ¯”ä¾‹ | ä¸è€ƒè™‘è¶‹åŠ¿ |
| OOBä¾èµ–å¤–éƒ¨ | å…¬å…±æœåŠ¡å™¨ | å¯èƒ½ä¸å¯ç”¨ |
| æ— éªŒè¯ç¼“å­˜ | æ¯æ¬¡é‡æ–°éªŒè¯ | æ•ˆç‡ä½ |

**ä¼˜åŒ–å»ºè®®**:

```python
# 1. è‡ªé€‚åº”éªŒè¯è½®æ•°
def determine_rounds(self, vuln_type: str, 
                     target_stability: float) -> int:
    base_rounds = {
        "sqli_time": 5,
        "sqli_boolean": 3,
        "xss": 2,
        "ssrf": 3,
    }.get(vuln_type, 3)
    
    # ä¸ç¨³å®šç›®æ ‡éœ€æ›´å¤šè½®æ•°
    if target_stability < 0.8:
        return min(10, base_rounds * 2)
    return base_rounds

# 2. è¶‹åŠ¿æ„ŸçŸ¥ç½®ä¿¡åº¦
def _calculate_confidence_enhanced(self, results: List[bool]) -> float:
    if not results:
        return 0.0
    
    base_conf = sum(results) / len(results)
    
    # æœ€è¿‘ç»“æœè¶‹åŠ¿åŠ æˆ
    recent = results[-3:] if len(results) >= 3 else results
    recent_positive = sum(recent)
    
    if recent_positive == len(recent):  # æœ€è¿‘å…¨é˜³æ€§
        return min(1.0, base_conf + 0.1)
    elif recent_positive == 0:  # æœ€è¿‘å…¨é˜´æ€§
        return max(0.0, base_conf - 0.1)
    return base_conf
```

---

### 4.2 æ™ºèƒ½Payloadå¼•æ“ (`modules/smart_payload_engine.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class TargetProfile:
    url, server, waf, framework, language, features
    - detect_server(response)
    - detect_waf(response)
    - detect_framework(response)
    - detect_language(response)

class SmartPayloadSelector:
    - select_payloads(vuln_type, target, max_count)
    - _score_payload(payload, target)
    - _get_historical_success_rate(payload)
    - _save_stats(payload, success)

class PayloadMutator:
    MUTATION_STRATEGIES = [
        "case_variation",
        "url_encode",
        "double_url_encode",
        "html_encode",
        "unicode_encode",
        "comment_split",
        "concat",
        "whitespace",
    ]
    
    - mutate(payload, waf) -> List[str]
    - _mutate_for_cloudflare(payload)
    - _mutate_for_modsecurity(payload)
```

**WAFæ£€æµ‹æ”¯æŒ**:

| WAF | æ”¯æŒ | ç»•è¿‡ç­–ç•¥ |
|-----|------|----------|
| Cloudflare | âœ… | ç¼–ç å˜å¼‚ |
| AWS WAF | âœ… | å‚æ•°æ±¡æŸ“ |
| ModSecurity | âœ… | æ³¨é‡Šåˆ†å‰² |
| Sucuri | âœ… | å¤§å°å†™ |
| Wordfence | âœ… | Unicode |
| F5 BIG-IP | âœ… | åˆ†å— |
| é˜¿é‡Œäº‘ç›¾ | âŒ | éœ€æ·»åŠ  |
| é•¿äº­é›·æ±  | âŒ | éœ€æ·»åŠ  |
| å®‰æ’WAF | âŒ | éœ€æ·»åŠ  |

**ä¼˜åŒ–å»ºè®®**:

```python
# 1. æ·»åŠ å›½äº§WAFæ”¯æŒ
WAF_SIGNATURES.update({
    "aliyun_waf": ["ali-cdn", "aegis", "aliyun"],
    "chaitin_safeline": ["chaitin", "safeline", "t1k"],
    "anheng_waf": ["anheng", "dbapp", "webray"],
    "knownsec_kss": ["knownsec", "kss", "jiasule"],
    "qianxin_waf": ["qianxin", "360"],
})

# 2. å¤šå±‚å˜å¼‚
def mutate_layered(self, payload: str, waf: str, 
                   layers: int = 3) -> List[str]:
    """å¤šå±‚å˜å¼‚ç»•è¿‡å¤æ‚WAF"""
    current = [payload]
    for _ in range(layers):
        next_layer = []
        for p in current:
            variants = self.mutate(p, waf)
            next_layer.extend(variants)
        current = list(set(next_layer))[:100]  # é™åˆ¶æ•°é‡
    return current
```

---

### 4.3 å¼‚æ­¥æ‰«æå™¨ (`modules/async_scanner.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class ScanResult:
    target, success, data, duration, error, retries

class CircuitBreaker:
    - record_failure(key)
    - record_success(key)
    - is_open(key) -> bool

class AdaptiveConcurrencyController:
    - record_response(response_time, success)
    - _adjust()
    - get_concurrency() -> int

class AsyncScanner:
    - _get_semaphore()
    - _update_semaphore()
    - _retry_with_backoff(coro_func, *args)
    - get_stats() -> ScannerStats

class AsyncPortScanner(AsyncScanner):
    - scan_port(host, port) -> bool
    - _grab_banner(host, port) -> str
    - scan(host, ports) -> List[int]

class AsyncDirScanner(AsyncScanner):
    COMMON_DIRS = [...]
    - check_path(base_url, path) -> Dict
    - scan(base_url, paths) -> List[Dict]

class AsyncVulnScanner(AsyncScanner):
    - scan_target(url, vuln_types) -> Dict
    - scan_batch(targets, vuln_types) -> List[Dict]
```

**å·²å®ç°çš„ç‰¹æ€§**:

- âœ… ç†”æ–­å™¨ (5æ¬¡å¤±è´¥è§¦å‘ï¼Œ30ç§’æ¢å¤)
- âœ… è‡ªé€‚åº”å¹¶å‘ (5-200åŠ¨æ€è°ƒæ•´)
- âœ… é‡è¯•æœºåˆ¶ (æŒ‡æ•°é€€é¿)
- âœ… å¼‚æ­¥ç«¯å£æ‰«æ
- âœ… å¼‚æ­¥ç›®å½•æ‰«æ

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | æè¿° | å½±å“ |
|------|------|------|
| HTTPå®¢æˆ·ç«¯æœªç»Ÿä¸€ | httpx/aiohttpæ··ç”¨ | è¿æ¥æ± åˆ†æ•£ |
| æ— å…¨å±€è¿æ¥æ±  | æ¯ä¸ªScanneråˆ›å»º | èµ„æºæµªè´¹ |
| æ¼æ´æ‰«æéƒ¨åˆ†å®ç° | åŸºç¡€æ¡†æ¶å­˜åœ¨ | åŠŸèƒ½ä¸å®Œæ•´ |

---

### 4.4 OOBæ£€æµ‹å™¨ (`modules/oob_detector.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class OOBInteraction:
    timestamp, protocol, remote_address, raw_request, identifier

class OOBResult:
    success, vuln_type, interactions, callback_url, payload_used

class InteractshClient:
    PUBLIC_SERVERS = ["oast.live", "oast.fun", "oast.site", "interact.sh"]
    - generate_url(identifier) -> str
    - generate_dns(identifier) -> str
    - poll(timeout) -> List[OOBInteraction]

class DNSLogClient:
    PLATFORMS = {"dnslog": {...}, "ceye": {...}}
    - generate_subdomain(identifier) -> str
    - poll() -> List[str]

class OOBDetector:
    PAYLOAD_TEMPLATES = {
        "ssrf": ["http://{callback}", ...],
        "xxe": ["<!DOCTYPE...>", ...],
        "sqli": ["'; EXEC xp_cmdshell...", ...],
        "rce": ["curl {callback}", "wget {callback}", ...],
    }
    
    - generate_callback(vuln_type, context) -> Tuple[str, str]
    - get_payloads(vuln_type) -> List[str]
    - inject_and_wait(url, param, vuln_type, timeout)
    - check_interactions() -> List[OOBInteraction]
```

**æ”¯æŒçš„OOBåœºæ™¯**:

| åœºæ™¯ | Payload | åè®® |
|------|---------|------|
| ç›²SSRF | HTTPè¯·æ±‚ | HTTP/HTTPS |
| ç›²XXE | å¤–éƒ¨å®ä½“ | HTTP/DNS |
| ç›²SQLi | xp_cmdshell/LOAD_FILE | HTTP/DNS |
| ç›²RCE | curl/wget/nslookup | HTTP/DNS |

**é—®é¢˜åˆ†æ**:

| é—®é¢˜ | æè¿° | å½±å“ |
|------|------|------|
| å…¬å…±æœåŠ¡å™¨ä¸ç¨³å®š | å¯èƒ½è¶…æ—¶/ä¸å¯ç”¨ | æ£€æµ‹å¤±è´¥ |
| æ— ç§æœ‰éƒ¨ç½²æ”¯æŒ | åªæœ‰å…¬å…±é€‰é¡¹ | ä¼ä¸šæ— æ³•ç”¨ |
| Payloadæ¨¡æ¿ä¸å®Œæ•´ | éƒ¨åˆ†åœºæ™¯ç¼ºå¤± | æ¼æ£€ |

---

### 4.5 Red Teamå·¥å…· (`modules/redteam_tools.py`) ğŸ”´

**ç°çŠ¶**: 46KB, 1498è¡Œ - **éœ€è¦æ‹†åˆ†**

**åŠŸèƒ½è¦†ç›–**:

| ç±»åˆ« | å·¥å…· | æè¿° |
|------|------|------|
| æ¨ªå‘ç§»åŠ¨ | `smb_exec`, `ssh_exec`, `wmi_exec`, `psexec`, `rdp_tunnel`, `winrm_exec` | è¿œç¨‹æ‰§è¡Œ |
| C2é€šä¿¡ | `beacon`, `dns_tunnel`, `http_tunnel`, `icmp_tunnel` | å‘½ä»¤æ§åˆ¶ |
| æ··æ·†å…æ€ | `payload_obfuscate`, `encoder_chain`, `packer` | ç»•è¿‡æ£€æµ‹ |
| æŒä¹…åŒ– | `scheduled_task`, `registry_run`, `service_install`, `startup_script` | ç»´æŒè®¿é—® |
| å‡­è¯è·å– | `memory_dump`, `file_search`, `keylogger` | è·å–å‡­æ® |
| ADæ”»å‡» | `kerberoast`, `asreproast`, `dcsync`, `zerologon`, `petitpotam` | åŸŸæ¸—é€ |

**å®‰å…¨é—®é¢˜**:

| é—®é¢˜ | ä½ç½® | ä¸¥é‡æ€§ |
|------|------|--------|
| æ— æˆæƒéªŒè¯ | å…¨å±€ | ğŸ”´ é«˜ |
| æ•æ„Ÿæ“ä½œæ— å®¡è®¡ | å…¨å±€ | ğŸ”´ é«˜ |
| å‡­è¯æ˜æ–‡å¤„ç† | å¤šå¤„ | ğŸŸ  ä¸­ |

**æ‹†åˆ†å»ºè®®**:

```
modules/redteam/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ lateral/
â”‚   â”œâ”€â”€ smb.py
â”‚   â”œâ”€â”€ ssh.py
â”‚   â”œâ”€â”€ wmi.py
â”‚   â”œâ”€â”€ psexec.py
â”‚   â””â”€â”€ winrm.py
â”œâ”€â”€ c2/
â”‚   â”œâ”€â”€ beacon.py
â”‚   â”œâ”€â”€ dns_tunnel.py
â”‚   â”œâ”€â”€ http_tunnel.py
â”‚   â””â”€â”€ icmp_tunnel.py
â”œâ”€â”€ evasion/
â”‚   â”œâ”€â”€ obfuscator.py
â”‚   â”œâ”€â”€ encoder.py
â”‚   â””â”€â”€ packer.py
â”œâ”€â”€ persistence/
â”‚   â”œâ”€â”€ scheduled_task.py
â”‚   â”œâ”€â”€ registry.py
â”‚   â””â”€â”€ service.py
â”œâ”€â”€ credential/
â”‚   â”œâ”€â”€ memory_dump.py
â”‚   â”œâ”€â”€ file_search.py
â”‚   â””â”€â”€ keylogger.py
â””â”€â”€ ad/
    â”œâ”€â”€ kerberos.py
    â”œâ”€â”€ ldap.py
    â””â”€â”€ domain_trust.py
```

---

## äº”ã€å·¥å…·å‡½æ•°åˆ†æ

### 5.1 æŠ¥å‘Šç”Ÿæˆå™¨ (`utils/report_generator.py`)

**ç±»ä¸æ–¹æ³•**:

```python
class ReportGenerator:
    - generate(session_id, format_type)  # html/json/markdown
    - _prepare_report_data(session)
    - _summarize_findings(findings)
    - _group_findings_by_type(findings)
    - _group_findings_by_target(findings)
    - _analyze_attack_chains(findings)
    - _calculate_cvss_distribution(findings)
    - _prioritize_remediation(findings)
    - _generate_executive_summary(data, session_id)
    - _generate_html(data, session_id)
    - _generate_json(data, session_id)
    - _generate_markdown(data, session_id)
```

**æŠ¥å‘Šæ ¼å¼æ”¯æŒ**:

| æ ¼å¼ | æ”¯æŒ | æ¨¡æ¿ |
|------|------|------|
| HTML | âœ… | Jinja2 |
| JSON | âœ… | å†…ç½® |
| Markdown | âœ… | Jinja2 |
| PDF | âŒ | éœ€æ·»åŠ  |
| DOCX | âŒ | éœ€æ·»åŠ  |

**æŠ¥å‘Šå†…å®¹**:

- æ‰§è¡Œæ‘˜è¦
- æ¼æ´ç»Ÿè®¡ (æŒ‰ä¸¥é‡æ€§/ç±»å‹/ç›®æ ‡)
- CVSSåˆ†å¸ƒ
- æ”»å‡»é“¾åˆ†æ
- ä¿®å¤å»ºè®®ä¼˜å…ˆçº§
- è¯¦ç»†å‘ç°åˆ—è¡¨

---

### 5.2 è¾“å…¥éªŒè¯å™¨ (`utils/input_validator.py`)

**éªŒè¯å‡½æ•°**:

```python
- validate_url(url) -> bool
- validate_ip(ip) -> bool
- validate_domain(domain) -> bool
- validate_port(port) -> bool
- validate_path(path) -> bool  # é˜²è·¯å¾„éå†
- validate_command(cmd) -> bool  # é˜²å‘½ä»¤æ³¨å…¥
- sanitize_input(input_str) -> str
- sanitize_filename(filename) -> str
```

**é˜²æŠ¤èƒ½åŠ›**:

| æ”»å‡»ç±»å‹ | é˜²æŠ¤ |
|----------|------|
| è·¯å¾„éå† | âœ… |
| å‘½ä»¤æ³¨å…¥ | âœ… |
| URLæ³¨å…¥ | âœ… |
| SQLæ³¨å…¥ | âš ï¸ åŸºç¡€ |

---

## å…­ã€ä»£ç è´¨é‡ç»¼åˆè¯„ä¼°

### 6.1 ä»£ç è§„æ¨¡é—®é¢˜

| æ–‡ä»¶ | å½“å‰è¡Œæ•° | å»ºè®®è¡Œæ•° | çŠ¶æ€ |
|------|----------|----------|------|
| vuln_tools.py | 4,034 | <500 | ğŸ”´ P0 |
| redteam_tools.py | 1,498 | <300 | ğŸ”´ P1 |
| vuln_verifier.py | 1,169 | <500 | ğŸŸ  P1 |
| mega_payloads.py | 775 | æ•°æ®æ–‡ä»¶ | âœ… å¯æ¥å— |
| web_scan_tools.py | 766 | <500 | ğŸŸ¡ P2 |
| ai_tools.py | 716 | <500 | ğŸŸ¡ P2 |

### 6.2 ä»£ç é‡å¤åˆ†æ

| é‡å¤æ¨¡å¼ | å‡ºç°æ¬¡æ•° | å»ºè®® |
|----------|----------|------|
| HTTPè¯·æ±‚+å¼‚å¸¸å¤„ç† | 50+ | ç»Ÿä¸€HTTPå®¢æˆ·ç«¯ |
| Payloadåˆ—è¡¨å®šä¹‰ | 10+ | ç»Ÿä¸€PayloadManager |
| å“åº”éªŒè¯é€»è¾‘ | 15+ | ç»Ÿä¸€ResponseValidator |
| æ—¥å¿—è®°å½•æ¨¡å¼ | 30+ | ç»Ÿä¸€Loggerè£…é¥°å™¨ |

### 6.3 å¼‚æ­¥åŒ–ç¨‹åº¦

| æ¨¡å— | åŒæ­¥ | å¼‚æ­¥ | å»ºè®® |
|------|------|------|------|
| ç«¯å£æ‰«æ | 20% | 80% | âœ… |
| ç›®å½•æ‰«æ | 30% | 70% | âœ… |
| æ¼æ´æ£€æµ‹ | 80% | 20% | âŒ éœ€æ”¹é€  |
| HTTPè¯·æ±‚ | 70% | 30% | âŒ éœ€æ”¹é€  |
| æŠ¥å‘Šç”Ÿæˆ | 100% | 0% | ğŸŸ¡ å¯é€‰ |

### 6.4 æµ‹è¯•è¦†ç›–

| æ¨¡å— | å•å…ƒæµ‹è¯• | é›†æˆæµ‹è¯• | è¦†ç›–ç‡ |
|------|----------|----------|--------|
| core/ | éƒ¨åˆ† | æ—  | ~20% |
| tools/ | å°‘é‡ | æ—  | ~10% |
| modules/ | å°‘é‡ | æ—  | ~15% |
| utils/ | è¾ƒå¥½ | æ—  | ~40% |

---

## ä¸ƒã€ä¼˜åŒ–ä¼˜å…ˆçº§æ¸…å•

### P0 - ç«‹å³ (1-2å‘¨)

| ä»»åŠ¡ | å·¥ä½œé‡ | å½±å“ |
|------|--------|------|
| æ‹†åˆ†vuln_tools.py | 5å¤© | å¯ç»´æŠ¤æ€§â†‘ |
| ä¿®å¤beacon.pyå®‰å…¨æ¼æ´ | 2å¤© | å®‰å…¨æ€§ |
| æ·»åŠ ç¼ºå¤±çš„SQLæ³¨å…¥æ£€æµ‹æ–¹æ³• | 2å¤© | æ£€å‡ºç‡â†‘ |
| å®Œå–„XSSä¸Šä¸‹æ–‡æ£€æµ‹ | 2å¤© | å‡†ç¡®æ€§â†‘ |

### P1 - çŸ­æœŸ (3-4å‘¨)

| ä»»åŠ¡ | å·¥ä½œé‡ | å½±å“ |
|------|--------|------|
| æ‹†åˆ†redteam_tools.py | 3å¤© | å¯ç»´æŠ¤æ€§â†‘ |
| æ¼æ´æ£€æµ‹å¼‚æ­¥åŒ– | 5å¤© | æ€§èƒ½â†‘ |
| æ·»åŠ å›½äº§WAFæ”¯æŒ | 2å¤© | é€‚ç”¨æ€§â†‘ |
| å®Œå–„OOBéªŒè¯ | 3å¤© | æ£€å‡ºç‡â†‘ |

### P2 - ä¸­æœŸ (5-8å‘¨)

| ä»»åŠ¡ | å·¥ä½œé‡ | å½±å“ |
|------|--------|------|
| å®ç°å†å²å­¦ä¹ ç³»ç»Ÿ | 5å¤© | æ™ºèƒ½åŒ–â†‘ |
| æ·»åŠ PDF/DOCXæŠ¥å‘Š | 3å¤© | æ˜“ç”¨æ€§â†‘ |
| æé«˜æµ‹è¯•è¦†ç›–ç‡åˆ°60% | 10å¤© | è´¨é‡â†‘ |
| å®Œå–„æ–‡æ¡£å’Œç¤ºä¾‹ | 5å¤© | å¯ç”¨æ€§â†‘ |

---

## å…«ã€ç›¸å…³æ–‡æ¡£

- [åŠŸèƒ½ä¼˜åŒ–æ–¹æ¡ˆ](./åŠŸèƒ½ä¼˜åŒ–æ–¹æ¡ˆ.md)
- [ä¼˜åŒ–è®¡åˆ’](./ä¼˜åŒ–è®¡åˆ’.md)
- [æ¶æ„ä¼˜åŒ–æ–¹æ¡ˆ](./æ¶æ„ä¼˜åŒ–æ–¹æ¡ˆ.md)
- [Webå®‰å…¨èƒ½åŠ›åˆ†æ](./Webå®‰å…¨èƒ½åŠ›åˆ†æä¸ä¼˜åŒ–æ–¹æ¡ˆ.md)
- [è¿ç§»æŒ‡å—](./è¿ç§»æŒ‡å—.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2026-01-13  
**ç»´æŠ¤è€…**: AutoRedTeam-Orchestrator Team
